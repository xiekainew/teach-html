<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	

	<script>
		// let fn, bar; // 1、进入全局上下文环境
		// bar = function(x) {
		//   let b = 5;
		//   fn(x + b); // 3、进入fn函数上下文环境
		// };
		// fn = function(y) {
		//   let c = 5;
		//   console.log(y + c); //4、fn出栈，bar出栈
		// };
		// debugger
		// bar(10); // 2、进入bar函数上下文环境

		// name = '北京'
		// let fn = function() {
		//   console.log(this.name)
		// }
		// let obj = {
		//   name: '山东',
		//   fn
		// }
		// fn() // 方法1
		// obj.fn() // 方法2
		// fn.call(obj) // 方法3
		// let instance = new fn() // 方法4
		// instance.name = 444

		// var o = obj.fn
		// o()


		// var t = (function t() {
		// 	var count = 0
		// 	return {
		// 		add: function() {
		// 			count += 1
		// 			console.log(count)
		// 		},
		// 		dec: function() {
		// 			count -= 1;
		// 			console.log(count)
		// 		}
		// 	}
		// })()
		// debugger
		// t.add();
		// t.dec();
		// t.dec();
		

		// var name = "window"
		// var p = {
		// 	name: 'Ken',
		// 	getName:function() {
		// 		return function() {
		// 			return this.name;
		// 		}
		// 	}
		// }
		// var getName = p.getName()
		// var _name = getName()
		// // var _name = getName.call(p)
		// console.log(_name)

		// var name = "window"
		// var p = {
		// 	name: 'Ken',
		// 	getName:function() {
		// 		var self = this;
		// 		// 内部函数对变量 this 的引用
		// 		return function() {
		// 			return self.name;
		// 		}
		// 	}
		// }
		// var getName = p.getName()
		// var _name = getName()
		// console.log(_name)
		// 
		var object = {
	  name: 'object',
	  getName: function() {
	    return function() {
	      console.log(this.name)
	    }
	  }
	}
	object.getName().call(object) // undefined
	// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows
	</script>
</body>
</html>